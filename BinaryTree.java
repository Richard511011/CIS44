//package TreePackage;import java.util.Iterator;import java.util.NoSuchElementException;import java.util.Stack ; // for Stackpublic class BinaryTree<T>{    protected BinaryNode<T> root;        public BinaryTree() {	     root = null;    } // end default constructor        public BinaryTree(T rootData) {	     root = new BinaryNode<T>(rootData);    } // end constructor   public BinaryTree(T rootData, BinaryTree<T> leftTree,                                  BinaryTree<T> rightTree) {       privateSetTree(rootData, leftTree, rightTree);   } // end constructor   public void setTree(T rootData)   {      root = new BinaryNode<T>(rootData);   } // end setTree      public void setTree(T rootData, BinaryTree<T> leftTree,		       BinaryTree<T> rightTree)   {      privateSetTree(rootData, leftTree, rightTree);   } // end setTree   private void privateSetTree(T rootData, BinaryTree<T> leftTree,                                           BinaryTree<T> rightTree)   {          root = new BinaryNode<T>(rootData);      if (leftTree != null)	       root.setLeftChild(leftTree.root);               if (rightTree != null)         root.setRightChild(rightTree.root);   }    public T getRootData () {        T rootData = null;        if (root != null)            rootData = root.getData();        return rootData;   }   public boolean isEmpty () {       return root == null;   }   public void clear (){       root = null;   }   // getHeight and getNumberOfNodes call same functions in BinaryNode<T>   public int getHeight () {       return root.getHeight ();   }    public int getNumberOfNodes () {       return root.getNumberOfNodes ();   }      public void inorderTraversal() {       Stack<BinaryNode<T>> nodeStack = new Stack<BinaryNode<T>>();       BinaryNode<T> currentNode = root;              while (!nodeStack.empty() || currentNode != null) {      	   while(currentNode != null) {      	       nodeStack.push(currentNode);      	       currentNode = currentNode.getLeftChild();      	   }      	   if(!nodeStack.empty()) {      	       BinaryNode<T> nextNode = nodeStack.pop();      	       System.out.println(nextNode.getData());      	       currentNode = nextNode.getRightChild();      	   }       }   }      public Iterator<T> getPreorderIterator() {       return new PreorderIterator();   }      public Iterator<T> getInorderIterator() {       return new InorderIterator();   }      private class PreorderIterator implements Iterator<T> {       private Stack<BinaryNode<T>> nodeStack;              public PreorderIterator() {	   nodeStack = new Stack<BinaryNode<T>>();	   if (root != null)	       nodeStack.push(root);       } // end default constructor              public boolean hasNext()  {	   return !nodeStack.isEmpty();       } // end hasNext              public T next() {	   BinaryNode<T> nextNode;	   	   if (hasNext()) {	       nextNode = nodeStack.pop();	       BinaryNode<T> leftChild = nextNode.getLeftChild();	       BinaryNode<T> rightChild = nextNode.getRightChild();	       	       // push into stack in reverse order of recursive calls	       if (rightChild != null)		   nodeStack.push(rightChild);	       	       if (leftChild != null)		   nodeStack.push(leftChild);	   }	   else {	       throw new NoSuchElementException();	   }	   return nextNode.getData();       } // end next              public void remove() {	   throw new UnsupportedOperationException();       } // end remove   } // end PreorderIterator       private class InorderIterator implements Iterator < T >   {       private Stack< BinaryNode < T >> nodeStack;       private BinaryNode< T > currentNode;       public InorderIterator () {	   nodeStack = new Stack < BinaryNode< T >> ();	   currentNode = root;       } // end default constructor       public boolean hasNext () {	   return !nodeStack.isEmpty () || (currentNode != null);       } // end hasNext       public T next ()       {	   BinaryNode< T > nextNode = null;	   // find leftmost node with no left child	   while (currentNode != null) {	       nodeStack.push (currentNode);	       currentNode = currentNode.getLeftChild ();	   } // end while	   // get leftmost node, then move to its right subtree	   if (!nodeStack.isEmpty ()) {	       nextNode = nodeStack.pop ();	       currentNode = nextNode.getRightChild ();	   }	   else	       throw new NoSuchElementException ();	   return nextNode.getData (); 	       } // end next                     public void remove () {	   throw new UnsupportedOperationException ();       } // end remove   } // end InorderIterator   		   		   		private int count1(BinaryNode<T> rootNode,T anObject) {   			   			if(rootNode!=null){   				   				if((rootNode.getData()).equals(anObject)) {   					return (1+count1(rootNode.getLeftChild(),anObject) +count1(rootNode.getRightChild(),anObject));   				} else   					return (count1(rootNode.getLeftChild(),anObject) +count1(rootNode.getRightChild(),anObject));   			}   			return 0;   		}   		public int count1(T anObject) {   			return count1(root,anObject);   		}   		   		public int count2(T anObject) {   			Iterator<T> iterator = new PreorderIterator();   			int counter =0;   			while(iterator.hasNext()) {   				if((iterator.next()).equals(anObject)){   					counter++;   				}   				   			}   			return counter;   		}   		   	   		private boolean islsomorphic(BinaryNode<T> treeOneNode,BinaryNode<T> treeTwoNode) {   			if((treeOneNode==null)&&(treeTwoNode==null))  // occurs when we traverse both trees to the end, that means that they share the same leaf position and thus are structurally the same   				return true;   				else if((treeOneNode!=null)&&(treeTwoNode!=null)){// if both of them are not null then we have not analyzed the full tree yet, so we continue comparisons with the left and right subtree of each tree   					boolean answer = islsomorphic(treeOneNode.getLeftChild(),treeTwoNode.getLeftChild())&&islsomorphic(treeOneNode.getRightChild(),treeTwoNode.getRightChild());   					return answer;   				}   				   			   			   		   			return false; // only occurs if one node is null and the other contains a value, means that the trees cannot have the same structure   		}   	 	public boolean islomorphic(BinaryTree<T> otherTree) {   			return islsomorphic(root,otherTree.root);   		}   		} // end BinaryTree